#' Compute delta delta Ct
#'
#'compute_ddct() calculates delta delta Ct from Ct values stored in a dataframe generated by format_sop().
#'
#' @param data a dataframe generated by format_sop().
#' @param hkg a character vector indicating the name(s) of the reference gene(s) to use for normalisation.
#' @param cal a character vector indicating the name of the reference sample to use for normalisation.
#'
#' @return A list storing the mean Ct values in "raw.data", and the relative quantification results in "rel.quant".
#'
#' @export
#'
#' @examples
#'
compute_ddct <- function(data, hkg, cal) {

  data <- data
  hkg <- hkg
  multi.hkg <- ifelse(length(hkg) > 1L, T, F)
  cal <- cal

  # Compute mean and sd of Ct values (per sample and target)

  data <- split(x = data, f = list(data$sample.id, data$tar.nm))

  data <- lapply(X = data,
                 FUN = function(x) { list(sample.id = x$sample.id[[1]],
                                          tar.nm = x$tar.nm[[1]],
                                          mean.ct = mean(x$ct, na.rm = T),
                                          sd.ct = sd(x$ct, na.rm = T)) })

  data <- Reduce(f = function(...) { merge(..., all = T)},
                 x = data)

  # Manage single vs multiple reference gene(s)

  if(isTRUE(multi.hkg)) {

    indiv.hkg.data <- data[data$tar.nm %in% hkg,]

    hkg.data <- split(x = indiv.hkg.data, f = indiv.hkg.data$sample.id)

    hkg.data <- lapply(X = hkg.data,
                       FUN = function(x) { list(sample.id = x$sample.id[[1]],
                                                tar.nm = paste0(x$tar.nm, collapse = " / "),
                                                mean.ct = mean(x$mean.ct, na.rm = T)) })

    hkg.data <- Reduce(f = function(...) { merge(..., all = T)},
                       x = hkg.data)
    hkg.data <- hkg.data[order(hkg.data$sample.id), , drop = F]

    data <- data[!data$tar.nm %in% hkg,]

    data <- data[order(data$sample.id), , drop = F]

  } else {

    hkg.data <- data[data$tar.nm == hkg,]

    hkg.data <- hkg.data[order(hkg.data$sample.id), , drop = F]

    data <- data[!data$tar.nm == hkg,]

    data <- data[order(data$sample.id), , drop = F]

  }

  # Perform relative quantification

  data <- split(x = data, f = data$sample.id)

  comp.ct.data <- lapply(X = names(data),
                         FUN = function(x) {
                           list(sample.id = x,
                                tar.nm = data[[x]]$tar.nm,
                                ref.nm = paste0(hkg, collapse = " / "),
                                delta.ct = data[[x]]$mean.ct - hkg.data[hkg.data$sample.id == x, "mean.ct"])
                         })

  comp.ct.data <- Reduce(f = function(...) { merge(..., all = T)},
                         x = comp.ct.data)

  comp.ct.data$delta.delta.ct <- comp.ct.data$delta.ct - comp.ct.data[comp.ct.data$sample.id == cal, "delta.ct"]

  comp.ct.data$two.power.minus.delta.delta.ct <- 2^(-comp.ct.data$delta.delta.ct)

  comp.ct.data <- comp.ct.data[order(comp.ct.data$sample.id, comp.ct.data$tar.nm), , drop = F]

  # Return result

  data <- Reduce(f = function(...) { merge(..., all = T)},
                 x = data)

  data <- merge(data, hkg.data, all = T)

  if(isTRUE(multi.hkg)) {
    data <- merge(data, indiv.hkg.data, all = T)
  }

  data <- data[order(data$sample.id, data$tar.nm), , drop = F]

  return(list(raw.data = data,
              rel.quant = comp.ct.data))
}
